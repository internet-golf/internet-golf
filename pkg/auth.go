package internetgolf

import (
	"fmt"
	"strings"

	"golang.org/x/crypto/bcrypt"
)

type ExternalUser struct {
	ExternalId      string `storm:"id"`
	ExternalSource  ExternalSourceType
	FullPermissions bool
	// TODO: implement granular permissions, like this:
	// deploymentsTheyHaveAccessTo []string
}

type BearerToken struct {
	Id string `storm:"id"`
	// generated by bcrypt - includes built-in salt
	TokenHash       []byte
	FullPermissions bool
	// TODO: implement granular permissions, like this:
	// deploymentsTheyHaveAccessTo []string
}

type AuthManager struct {
	Db Db
}

func (a *AuthManager) getPermissionsForRequest(remoteAddr string, authHeader string) (Permissions, error) {
	if l := (LocalReqAuthChecker{}); l.setReqData(remoteAddr, authHeader) {
		fmt.Println("automatically trusting request from " + remoteAddr)
		return &l, nil
	} else if g := (GithubAuthChecker{Db: a.Db}); g.setReqData(remoteAddr, authHeader) {
		return &g, nil
	} else if b := (BearerTokenAuthChecker{Db: a.Db}); b.setReqData(remoteAddr, authHeader) {
		return &b, nil
	}
	return nil, fmt.Errorf("could not check auth for header value \"%s\"", authHeader)
}

func (a *AuthManager) registerExternalUser(e ExternalUser) {
	a.Db.SaveExternalUser(e)
}

func (a *AuthManager) createBearerToken(fullPermissions bool) (string, error) {
	return (&BearerTokenAuthChecker{Db: a.Db}).createBearerToken(fullPermissions)
}

type Permissions interface {
	// returns false if the given concrete implementation of Permissions is not
	// suitable for the given request data
	setReqData(remoteAddr string, authHeader string) bool
	canCreateDeployment() bool
	canModifyDeployment(d *Deployment) bool
	canViewDeployment(d *Deployment) bool
	// can add external users and bearer tokens
	canCreateCredentials() bool
}

// if a request comes from the same machine as the server (i.e. comes from
// 127.0.0.1), this lets it do whatever it wants.
//
// this is similar to how you can access caddy's admin api from the same machine
// of it and just do whatever.
//
// implements the interface `Permissions`.
type LocalReqAuthChecker struct{}

func (l *LocalReqAuthChecker) setReqData(remoteAddr string, authHeader string) bool {
	return remoteAddr == "127.0.0.1" || strings.HasPrefix(remoteAddr, "127.0.0.1:")
}
func (l *LocalReqAuthChecker) canModifyDeployment(_ *Deployment) bool {
	return true
}
func (l *LocalReqAuthChecker) canCreateDeployment() bool {
	return true
}
func (l *LocalReqAuthChecker) canViewDeployment(_ *Deployment) bool {
	return true
}
func (l *LocalReqAuthChecker) canCreateCredentials() bool {
	return true
}

// provides bearer token-based authorization. implements the Permissions interface.
type BearerTokenAuthChecker struct {
	Db    Db
	token BearerToken
}

func (b *BearerTokenAuthChecker) createBearerToken(fullPermissions bool) (string, error) {
	var token, id string
	for {
		token, id = getRandomToken()
		existing, err := b.Db.GetBearerToken(id)
		if err != nil && len(existing.Id) == 0 {
			break
		}
	}
	tokenHash, err := bcrypt.GenerateFromPassword([]byte(token), 14)
	if err != nil {
		return "", err
	}
	b.Db.SaveBearerToken(BearerToken{Id: id, TokenHash: tokenHash, FullPermissions: fullPermissions})
	return id + "." + token, nil
}

func (b *BearerTokenAuthChecker) setReqData(remoteAddr string, authHeader string) bool {
	comps := strings.Split(authHeader, " ")
	if len(comps) != 2 || comps[0] != "Bearer" {
		return false
	}
	tokenWithId := comps[1]
	tokenComps := strings.Split(tokenWithId, ".")
	if len(tokenComps) != 2 {
		// should this be a panic? what would the implications be?
		panic("invalid token value received; it should have the format [id].[content]")
	}
	id := tokenComps[0]
	token := tokenComps[1]
	tokenStruct, tokenErr := b.Db.GetBearerToken(id)
	if tokenErr != nil {
		panic("could not find bearer token matching input")
	}
	compareErr := bcrypt.CompareHashAndPassword(tokenStruct.TokenHash, []byte(token))
	if compareErr != nil {
		panic("token content is not a match")
	}
	b.token = tokenStruct
	return true
}
func (b *BearerTokenAuthChecker) canModifyDeployment(_ *Deployment) bool {
	return b.token.FullPermissions
}
func (b *BearerTokenAuthChecker) canCreateDeployment() bool {
	return b.token.FullPermissions
}
func (b *BearerTokenAuthChecker) canViewDeployment(_ *Deployment) bool {
	return b.token.FullPermissions
}
func (b *BearerTokenAuthChecker) canCreateCredentials() bool {
	return b.token.FullPermissions
}
